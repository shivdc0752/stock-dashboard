import {
  BarController,
  BarElement,
  Chart,
  clipArea,
  defaults,
  isNullOrUndef,
  unclipArea,
  valueOrDefault
} from "./chunk-ZBFT2S5F.js";
import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// node_modules/chartjs-chart-financial/dist/chartjs-chart-financial.esm.js
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps(["x", "low", "high", "width", "height"], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return { left, top, right, bottom };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const bounds = !bar || skipX && skipY ? false : getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
}
var FinancialElement = class extends BarElement {
  height() {
    return this.base - this.y;
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
  getCenterPoint(useFinalPosition) {
    const { x, low, high } = this.getProps(["x", "low", "high"], useFinalPosition);
    return {
      x,
      y: (high + low) / 2
    };
  }
  tooltipPosition(useFinalPosition) {
    const { x, open, close } = this.getProps(["x", "open", "close"], useFinalPosition);
    return {
      x,
      y: (open + close) / 2
    };
  }
};
__publicField(FinancialElement, "defaults", {
  backgroundColors: {
    up: "rgba(75, 192, 192, 0.5)",
    down: "rgba(255, 99, 132, 0.5)",
    unchanged: "rgba(201, 203, 207, 0.5)"
  },
  borderColors: {
    up: "rgb(75, 192, 192)",
    down: "rgb(255, 99, 132)",
    unchanged: "rgb(201, 203, 207)"
  }
});
var defaults2 = Chart.defaults;
var OhlcElement = class extends FinancialElement {
  draw(ctx) {
    const me = this;
    const { x, open, high, low, close } = me;
    const armLengthRatio = valueOrDefault(me.armLengthRatio, defaults2.elements.ohlc.armLengthRatio);
    let armLength = valueOrDefault(me.armLength, defaults2.elements.ohlc.armLength);
    if (armLength === null) {
      armLength = me.width * armLengthRatio * 0.5;
    }
    if (close < open) {
      ctx.strokeStyle = valueOrDefault(me.options.borderColors ? me.options.borderColors.up : void 0, defaults2.elements.ohlc.borderColors.up);
    } else if (close > open) {
      ctx.strokeStyle = valueOrDefault(me.options.borderColors ? me.options.borderColors.down : void 0, defaults2.elements.ohlc.borderColors.down);
    } else {
      ctx.strokeStyle = valueOrDefault(me.options.borderColors ? me.options.borderColors.unchanged : void 0, defaults2.elements.ohlc.borderColors.unchanged);
    }
    ctx.lineWidth = valueOrDefault(me.lineWidth, defaults2.elements.ohlc.lineWidth);
    ctx.beginPath();
    ctx.moveTo(x, high);
    ctx.lineTo(x, low);
    ctx.moveTo(x - armLength, open);
    ctx.lineTo(x, open);
    ctx.moveTo(x + armLength, close);
    ctx.lineTo(x, close);
    ctx.stroke();
  }
};
__publicField(OhlcElement, "id", "ohlc");
__publicField(OhlcElement, "defaults", {
  ...FinancialElement.defaults,
  lineWidth: 2,
  armLength: null,
  armLengthRatio: 0.8
});
var FinancialController = class extends BarController {
  getLabelAndValue(index) {
    const me = this;
    const parsed = me.getParsed(index);
    const axis = me._cachedMeta.iScale.axis;
    const { o, h, l, c } = parsed;
    const value = `O: ${o}  H: ${h}  L: ${l}  C: ${c}`;
    return {
      label: `${me._cachedMeta.iScale.getLabelForValue(parsed[axis])}`,
      value
    };
  }
  getUserBounds(scale) {
    const { min, max, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
  }
  /**
   * Implement this ourselves since it doesn't handle high and low values
   * https://github.com/chartjs/Chart.js/issues/7328
   * @protected
   */
  getMinMax(scale) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const axis = meta.iScale.axis;
    const otherScale = this._getOtherScale(scale);
    const { min: otherMin, max: otherMax } = this.getUserBounds(otherScale);
    if (_parsed.length < 2) {
      return { min: 0, max: 1 };
    }
    if (scale === meta.iScale) {
      return { min: _parsed[0][axis], max: _parsed[_parsed.length - 1][axis] };
    }
    const newParsedData = _parsed.filter(({ x }) => x >= otherMin && x < otherMax);
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < newParsedData.length; i++) {
      const data = newParsedData[i];
      min = Math.min(min, data.l);
      max = Math.max(max, data.h);
    }
    return { min, max };
  }
  /**
   * @protected
   */
  calculateElementProperties(index, ruler, reset, options) {
    const me = this;
    const vscale = me._cachedMeta.vScale;
    const base = vscale.getBasePixel();
    const ipixels = me._calculateBarIndexPixels(index, ruler, options);
    const data = me.chart.data.datasets[me.index].data[index];
    const open = vscale.getPixelForValue(data.o);
    const high = vscale.getPixelForValue(data.h);
    const low = vscale.getPixelForValue(data.l);
    const close = vscale.getPixelForValue(data.c);
    return {
      base: reset ? base : low,
      x: ipixels.center,
      y: (low + high) / 2,
      width: ipixels.size,
      open,
      high,
      low,
      close
    };
  }
  draw() {
    const me = this;
    const chart = me.chart;
    const rects = me._cachedMeta.data;
    clipArea(chart.ctx, chart.chartArea);
    for (let i = 0; i < rects.length; ++i) {
      rects[i].draw(me._ctx);
    }
    unclipArea(chart.ctx);
  }
};
__publicField(FinancialController, "overrides", {
  label: "",
  parsing: false,
  hover: {
    mode: "label"
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "open", "high", "low", "close"]
    }
  },
  scales: {
    x: {
      type: "timeseries",
      offset: true,
      ticks: {
        major: {
          enabled: true
        },
        source: "data",
        maxRotation: 0,
        autoSkip: true,
        autoSkipPadding: 75,
        sampleSize: 100
      }
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      intersect: false,
      mode: "index",
      callbacks: {
        label(ctx) {
          const point = ctx.parsed;
          if (!isNullOrUndef(point.y)) {
            return defaults.plugins.tooltip.callbacks.label(ctx);
          }
          const { o, h, l, c } = point;
          return `O: ${o}  H: ${h}  L: ${l}  C: ${c}`;
        }
      }
    }
  }
});
var OhlcController = class extends FinancialController {
  updateElements(elements, start, count, mode) {
    const reset = mode === "reset";
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const options = sharedOptions || this.resolveDataElementOptions(i, mode);
      const baseProperties = this.calculateElementProperties(i, ruler, reset, options);
      if (includeOptions) {
        baseProperties.options = options;
      }
      this.updateElement(elements[i], i, baseProperties, mode);
    }
  }
};
__publicField(OhlcController, "id", "ohlc");
__publicField(OhlcController, "defaults", {
  ...FinancialController.defaults,
  dataElementType: OhlcElement.id,
  datasets: {
    barPercentage: 1,
    categoryPercentage: 1
  }
});
var CandlestickElement = class extends FinancialElement {
  draw(ctx) {
    const me = this;
    const { x, open, high, low, close } = me;
    let borderColors = me.options.borderColors;
    if (typeof borderColors === "string") {
      borderColors = {
        up: borderColors,
        down: borderColors,
        unchanged: borderColors
      };
    }
    let borderColor;
    if (close < open) {
      borderColor = valueOrDefault(borderColors ? borderColors.up : void 0, defaults.elements.candlestick.borderColors.up);
      ctx.fillStyle = valueOrDefault(me.options.backgroundColors ? me.options.backgroundColors.up : void 0, defaults.elements.candlestick.backgroundColors.up);
    } else if (close > open) {
      borderColor = valueOrDefault(borderColors ? borderColors.down : void 0, defaults.elements.candlestick.borderColors.down);
      ctx.fillStyle = valueOrDefault(me.options.backgroundColors ? me.options.backgroundColors.down : void 0, defaults.elements.candlestick.backgroundColors.down);
    } else {
      borderColor = valueOrDefault(borderColors ? borderColors.unchanged : void 0, defaults.elements.candlestick.borderColors.unchanged);
      ctx.fillStyle = valueOrDefault(me.backgroundColors ? me.backgroundColors.unchanged : void 0, defaults.elements.candlestick.backgroundColors.unchanged);
    }
    ctx.lineWidth = valueOrDefault(me.options.borderWidth, defaults.elements.candlestick.borderWidth);
    ctx.strokeStyle = borderColor;
    ctx.beginPath();
    ctx.moveTo(x, high);
    ctx.lineTo(x, Math.min(open, close));
    ctx.moveTo(x, low);
    ctx.lineTo(x, Math.max(open, close));
    ctx.stroke();
    ctx.fillRect(x - me.width / 2, close, me.width, open - close);
    ctx.strokeRect(x - me.width / 2, close, me.width, open - close);
    ctx.closePath();
  }
};
__publicField(CandlestickElement, "id", "candlestick");
__publicField(CandlestickElement, "defaults", {
  ...FinancialElement.defaults,
  borderWidth: 1
});
var CandlestickController = class extends FinancialController {
  updateElements(elements, start, count, mode) {
    const reset = mode === "reset";
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const options = sharedOptions || this.resolveDataElementOptions(i, mode);
      const baseProperties = this.calculateElementProperties(i, ruler, reset, options);
      if (includeOptions) {
        baseProperties.options = options;
      }
      this.updateElement(elements[i], i, baseProperties, mode);
    }
  }
};
__publicField(CandlestickController, "id", "candlestick");
__publicField(CandlestickController, "defaults", {
  ...FinancialController.defaults,
  dataElementType: CandlestickElement.id
});
__publicField(CandlestickController, "defaultRoutes", BarController.defaultRoutes);
export {
  CandlestickController,
  CandlestickElement,
  OhlcController,
  OhlcElement
};
/*! Bundled license information:

chart.js/dist/helpers.js:
  (*!
   * Chart.js v4.4.7
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chartjs-chart-financial/dist/chartjs-chart-financial.esm.js:
  (*!
   * @license
   * chartjs-chart-financial
   * http://chartjs.org/
   * Version: 0.2.1
   *
   * Copyright 2024 Chart.js Contributors
   * Released under the MIT license
   * https://github.com/chartjs/chartjs-chart-financial/blob/master/LICENSE.md
   *)
*/
//# sourceMappingURL=chartjs-chart-financial.js.map
